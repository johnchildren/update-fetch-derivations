#!/usr/bin/env perl

use warnings;
use strict;
use feature qw(say);

=head1 update-fetch-derivations

Update GitHub fetch revisions and hashes for a given nix source file.

Example:

  update-fetch-derivation my-file.nix

=cut

if ($#ARGV < 0) {
  say "Need an argument for what file to process.";
  say <<END;
update-fetch-derivations
    Update GitHub fetch revisions and hashes for a given nix source file.

    Example:

      update-fetch-derivation my-file.nix
END
  exit 1;
}

my $target = $ARGV[0];

local $/ = undef;
open my $read, '<', $target or die "Couldn't open existing file $target";
my $string = <$read>;
close $read;

my $fetchFromGitHubRegex = "fetchFromGitHub \\{.+?\\}";
my @literals = split /$fetchFromGitHubRegex/s, $string;
my @matches = $string =~ /$fetchFromGitHubRegex/gs;

for (my $i =0; $i <= $#matches; $i++) {
  my $match = $matches[$i];

  (my $owner) = $match =~ /owner = "(.*?)";/s;
  (my $repo) = $match =~ /repo = "(.*?)";/s;

  my $result = `prefetch-github -o $owner -r $repo`;
  if ($! != 0) {
    die "Errored on prefetch-github for match: $match";
  }

  (my $rev) = $result =~ /rev = "(.*?)";/s;
  (my $sha256) = $result =~ /sha256 = "(.*?)";/s;

  $match =~ s/(rev = ")(.*?)(";)/$1$rev$3/s;
  $match =~ s/(sha256 = ")(.*?)(";)/$1$sha256$3/s;

  $matches[$i] = $match;
}

my $output = "";
for (my $i = 0; $i <= $#matches; $i++) {
  $output .= $literals[$i];
  $output .= $matches[$i];
}
$output .= $literals[-1];

open my $write, '>', $target or die "Couldn't open new file $target";
print $write $output;
close $write;

my $matchCountHuman = $#matches + 1;
say "Updated $matchCountHuman matches of fetchFromGitHub in $target";
